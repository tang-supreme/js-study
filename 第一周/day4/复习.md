# 复习

- 循环结构的 do {} while () 循环
  + 是一个和 while 循环基本一致的东西
  + 不管条件是否满足，先执行一遍代码，在开始进行条件判断的循环

- for 循环
  + 也是循环结构的一种
  + `for (初始化; 条件判断; 自身改变) { 要执行的代码 }`

- break 关键字
  + 在循环体内使用的时候，当遇到 break 关键字的时候直接结束循环

- continue 关键字
  + 在循环体内使用的hi收，当遇到 continue 关键字的时候，结束循环的本次，直接进行下一次

- 练习

1. 求1+2!+3!+...+20!的值
```javascript
  var and = 0
  for (var j = 1; j <= 20; j++) {
    // j 拿到的就是 1 ~ 20 的所有数字

    var sum = 1
    for (var i = j; i >= 1; i--) {
      sum *= i
    }

    // 当 j = 1 的时候 sum 就是 1 的阶乘
    // 当 j = 2 的时候 sum 就是 2 的阶乘
    and += sum

  }

  console.log(and)
```

2. 有一个棋盘，有64个方格，在第一个方格里面放1粒芝麻重量是0.00001kg，第二个里面放2粒，第三个里面放4，棋盘上放的所有芝麻的重量
```javascript
  // 1   1
  // 2   2
  // 3   4
  // 4   8
  // 5   16
  // 先计算 64 个格子里面一共由多少个芝麻
  var sum = 0
  var count = 1
  for (var i = 1; i <= 64; i++) {
    // i 式 1 ~ 64 的数字

    if (i !== 1) {
      count *= 2
    }

    // 当 i === 1 的时候 count === 1
    // 当 i === 2 的时候 count *= 2 count === 2
    // 当 i === 3 的时候 count *= 2 count === 4
    // 当 i === 4 的时候 count *= 2 count === 8
    // 当 i === 5 的时候 count *= 2 count === 16

    // 每一次循环把 count 叠加到 sum 上
    // 当 i === 1 的时候，sum += 1  sum = 1
    // 当 i === 2 的时候，sum += 2  sum = 3
    // 当 i === 3 的时候，sum += 4  sum = 7
    // 当 i === 4 的时候，sum += 8  sum = 15
    // 当 i === 5 的时候，sum += 16  sum = 31

    sum += count
  }

  // 当循环结束的时候，sum 就是 64 个格子里面所有芝麻数量的总和
  console.log(sum * 0.00001 + 'kg')
```


## 上午复习

- 函数
  + 函数就是一个承载代码段的盒子
  + 函数是一个复杂数据类型

- 函数的两个阶段
  + 定义阶段
    1. 声明式函数
      + `function fn() {}`
    2. 赋值式函数
      + `var fun = function () {}`
  + 调用阶段
    + 调用方式都是 函数名()
    + 声明式函数可以在声明之前调用，也可以在声名之后调用
    + 赋值式函数只能在声名之后调用

- 函数定义阶段做的事情（熟读并背诵全文）
  1. 开辟一个存储空间
  2. 把函数体内的代码一模一样的存储在这个空间中（不解析变量）
  3. 把空间的地址给到变量名（函数名）

- 函数的参数
  + 形参
    + 就是在函数体内定义的变量
    + 只能在函数体内使用
    + 函数体外使用不了
    + 函数体内形参的值取决于函数调用的时候传递的实参
  + 实参
    + 就是在函数调用的时候给形参赋值的

- 函数参数的个数关系
  + 两种参数数量一致的时候
    + 一一对应
  + 实参多
    + 前面的一一对应，多出来的实参在函数体内没有变量接受
  + 形参多
    + 前面的一一对应，多出来的没有实参给赋值，在函数体内使用的时候就是 undefined

- arguments
  + 每一个函数体内自带的变量
  + 所有实参的集合
  + 是一个长得很像数组的数据集合，但是不是数组，是伪数组
  + 有一个属性叫做 length，表示的数据集合的长度，就是数据集合中有多少数据
  + 也是按照 索引 进行排列的
  + 也可以按照 索引 来获取里面的某一个数据

- 练习题

1. 编写一个函数，计算三个数字的大小，按从小到大顺序输出
```javascript
  // 1. 找到一个最大的数字
  // 2. 找到一个最小的数字
  // 3. 除了这两个数字，剩下的哪一个就是中间的

  function fn() {
    // arguments 接收到是一个伪数组
    // [19, 15, 21]

    // 假设这个伪数组里面的第 0 个是最小的
    var min = arguments[0]

    for (var i = 0; i < arguments.length; i++) {
      // 如果这里的某一个数字比我假设的数字小
      // 把我假设的替换掉
      if (arguments[i] < min) {
        min = arguments[i]
      }
    }

  }

  fn(19, 15, 21)
```


## 下午回顾

- return
  1. 终断函数
    + 写在 return 后面行的代码全部都不执行了
  2. 给函数一个返回值
    + 不写 return ，函数的返回值是 undefined
    + 如果写了 return，没有写内容，返回值 undefined
    + 如果写了 return，并且写了内容，那么你写的内容就是函数的返回值

- 函数和事件的结合
  + 常见的事件
  + 鼠标事件
  + 键盘事件
  + 表单事件
  + 浏览器事件
    + onload 所有页面资源加载完毕后触发
    + onresize 浏览器窗口大小改变的时候触发
    + onscroll 浏览器滚动条滚动的时候触发
  + 其他事件

- 预解析
  + 是在所有的代码执行之前对代码进行通读并解释
    1. var 关键字的时候，告诉浏览器变量名可以使用，但是没有赋值
    2. 声明式函数，告诉浏览器函数名（变量名）可以使用，并且这个变量名的值是一个函数地址

- 预解析的无节操
  1. 不管 if 条件是否成立，代码块里面的代码会进行预解析
  2. return 后面的代码虽然不执行，但是会进行预解析

- 熟读并背诵全文
  + 函数定义阶段
    1. 开辟一个存储空间
    2. 把代码一摸一样的存进去（不解析变量）
    3. 把空间地址给到变量名（函数名）
  + 函数调用阶段
    1. 按照函数名存储的地址找到对应的存储空间
    2. 形参复制
    3. 预解析
    4. 把存储空间内的代码拿出来执行一遍（解析变量）
